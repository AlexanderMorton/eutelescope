##This is the GBL fitter with a strip sensor DUT. 
#Blue(#) markings are running processors and changing things in the config
TGeo reads the thickness of the sensors from the sensitive area of the gear.
50 micron for mimosas, 300 micron for DUT
Test with 10k events which was enough for alignment of DUT without XY rotations.

The gear file used from the begining of the process: gear-beforeAlign-000703.xml.
This has the correct correlations but offsets are not taken into account.
The sequence of steering files to run to create initial tracks.
js => jobsub -c config/config -csv runlist/runlist
###js converter 703
###js clustering 703
###js hitmaker 703   #################################################

Prealignment will produce a gear called: gear-beforeAlign-000703_pre.xml 
Note there is heavy misalignment in the last plane!!! 
Prealignment of this plane has been done but is not adviced. 
#####################################################################

###js patternRecognition 703########################################
Triplets are formed from hits on the three planes of each arm of the telescope. The three hits that form the triplet are just mini tracks which are extrapolated to a central point in the centre of the setup. This extrapolation is constant in incidence for non magnetic field runs. However incidence is a variable with curvature so this must be taken into account in that situation. See noDUTExample.

The three planes which create each triplet are first searched in the first and last plane of the three for matching hits to form a doublet. If in the xy plane of the global frame they have a residual less than this (DoubletDistCut) cut then match the hits to form a doublet. 
Incidence and curvature are taken into account in the matching here and throughout
#DoubletDistCut = 1 1 << single # are cuts you will find in the config file
Use the doublet to link hits on the central plane to itself. This is done using the information of the hits of the doublet
The constrast with daf fitter pattern recognition which uses a clustering technique with an initial slope assumed. This does not use the information of the hit.
#DoubletCenDistCut = 1 1
Create triplets from hits on each arm now.
Predicted position at central point and slope must agree with the cuts given:
#TripletConnectDistCut = 0.5 0.5
#TripletSlopeCuts = 0.01 0.01
These planes will not create a state. IMPORTANT:TO EXCLUDE A PLANE IN ALIGNMENT DO IT HERE. SO PASS TRACKS WITH NO PLANE 8 FOR INITIALI ALIGNMENT ATTEMPT WITHOUT DUT
#excludeplanes=  8  
Plane dimension is needed to determine in what directions we should compare tracks and DUT hits
#planeDimensions= 2 2 2 1 2 2 2 
This is used to determine the initial curvature of the track at plane 0
#InitialDisplacement=0

Running the above pattern recognition with the prealigned gear (gear-beforeAlign-000703_pre.xml) should give:

21:38:31 jobsub.patternRecognition(INFO): [ MESSAGE5 "TrackSearch"] Percentage tracks without DUT hit: 0.3724
The number of tracks reconstructed by mimosas but a a corresponding hit on the DUT is not found. 
Not cut is applied to a DUT hit. The same track can be associated to different DUT hits.
21:38:31 jobsub.patternRecognition(INFO): [ MESSAGE5 "TrackSearch"] Number of tracks per event: 0.688516
21:38:31 jobsub.patternRecognition(INFO): [ MESSAGE5 "TrackSearch"] Number of left arm triplets per event: 2.0683
The total number of three hits close enough to form a triplet on the arm up stream
21:38:31 jobsub.patternRecognition(INFO): [ MESSAGE5 "TrackSearch"] Number of right arm triplets per event: 1.95249
Same but for down stream
#######################################################################

#js GBLAlign 703 #####################################################
Without running iterAlign we can find the correct alignment parameters
This process is similar to Daffitter and definition of parameters will be given below 

Alignment is done using GBL tracks and millepede. 
Millepede will try to find the minimum chi2 for a series of independent residuals (All residual assume a gaussian form). These residuals compose each measured hit and predicted track position. This is in the measurement frame, i.e the plane which the position of the hit and prediction would sit on the physical plane. This residual will change due to two different types of parameters:
 The local parameters: the parameters which describe the most likely track (Kink, incidence position). This is just changing the track we predicted.
 The global parameters: The position of the detector. You can think of this as keeping the track constant now and moving the detector planes.

 We are interest in the second type of parameter since we what to know the position of the detector. Therefore the first are taken as nuissance parameters and only the global is determined. This is done in a usual manner, with a least squares fit, since the problem is just minimising a chi2 distribution. The only difference is the linear algebra which makes the process efficient. 

The chi2 is cut internally by millepede. This is cut using the chi2 which corresponds to 0.27% p-value estimate. This of course will vary with resolution of hit which can easily lead to problems. Especially since the errors are the statistical and systematic errors combined.
The 30 and 6 will increase the chi2 value which corresponds to 0.27% p-value by that multiple on the first and then second iteration of millepede.
There is not much point changing this cut in most situations. Since by default the cut is large.
#pede          = chiscut 30  6

The planes which you can move while keeping the tracks produced constant for an initial mimosa without DUT fit are:

#FixXshifts=0  5 8 
#FixYshifts=0  5 8 
#FixZshifts=0 1 2 3 4 5 8 
#FixXrot=   0 1 2 3 4 5 8
#FixYrot=   0 1 2 3 4 5 8
#FixZrot=   0   5 8 

The first and last plane must be fixed at this point in alignment. Prealignment has moved this plane to possibly ~0.5 mm precision. 
The input errors are the uncertainty we should expect the gaussian distributions of each residual to have AFTER the fit. 
Therefore if you can not align with errors close to that of the DUT then there must be a systematic error remaining afterwards.
Otherwise the initial track descripition was so wrong that no solution could be found.

Alignment from prealignment can be found setting the resolution to (All plane are fixed as above):

#r = 0.03
#dutX=0.05
#dutY=100000000
#
The new output gear is stored as:
#alignedGear-xyzShift-zRot-DUT-xyShift-zRot-run000703.xml

#js GBLAlign 703

The output gear for no DUT is(You can of course name it different when running): alignedGear-xyzShift-zRot-noDUT-run000703.xml   


NEED TO CHANGE THE RUNLIST TO THE NEW OUTPUT GEAR!!!
NOTE PATTERN RECOGNITION MUST BE RAN AGAIN BEFORE YOU RERUN ALIGNMENT!!!!!
After doing this we can free up another alignment parameter. 


#FixXshifts=0  5  
#FixYshifts=0  5  
#FixZshifts=0 1 2 3 4 5 8 
#FixXrot=   0 1 2 3 4 5 8
#FixYrot=   0 1 2 3 4 5 8
#FixZrot=   0   5  

You should never fix planes after they have been freed. This will produce a gear like so: alignedGear-xyzShift-zRot-DUT-xyShift-zRot-run000703.xml 
Do the same again now free up z position and produce gear: alignedGear-xyzShift-zRot-DUT-xyzShift-zRot-run000703.xml
Can repeat with new gear to check convergence: alignedGear-xyzShift-zRot-DUT-xyzShift-zRot-v2-run000703.xml  (v2 => run with the new gear file again,NOT NEEDED, JUST A CHECK)


From here I get rotations of about 0.1 radians 5 deg with rotations ZX. Seems too large.  
####################################################################################################################
Using this gear file with the almost complete alignment you can use the track selection processor and analysis. 


