##Guide to GBL Examples##
#(Hash sign) denotes processor or config parameter.
This guide does not go into the mathematics of the implementation of GBL in EUTelescope. However it will give you an overview of each step for all the examples. 
The idea is give a good overview of what you are doing at each step so you are not blindly following commands. The introduction is split by processor. 
Each example also has a readme file to better explain specific information for that example. It also give the commands needed to run each example.

#Converter, clustering, hitmaker. 
This is the same as any example you have used before. You want to go through each step in any way you would like. As long as you have hits in the local frame ready to pass to pattern recognition. The hit passed with be of TrackerHit type and will be changed by EUTelPatRecTriplet (The GBL pattern recognition) to EUTelHit. This is done to allow any information which might be need for analysis to be attached easily. Otherwise you would need to use the standard inputs of TrackerHit which is messy.

##Pattern Recognition.

There are many different forms of pattern recognition. So Daffitter extrapolates all the hits - assuming some initial incidence - to the first plane and clusters. 
This is useful since it dones not need the relationship between the hits and therefore makes the process simpler. By this I mean that all tracks have the same incidence. 

You can go one step further and begin to use a combination of two hits from any part of the detector to form a track and then attach hits close to this predicted track. 
This is an advantage since you can then estimate the incidence for each track. This method can also be extended to look for two hits on each arm of the telescope and then extrapolating to a central position to link the two possible tracks on each arm to form a complete track. This method is what is used for the GBL pattern recognition at the moment.
This can be seen in EUTelPatRecTriplets.cc and in action in all the examples. 

As discussed you can relate the hit information in many ways. However one way is never enough. So the EUTelPatRecTriplets has two modes:
 
The first is a triplet finder (alignment mode, mode 1): It associates 3 hits on separate planes on each arm of the telescope using geometric considerations. 
Then it extraploates the track formed by these 3 hits to some central point and links the 3 hits on each arm together if they pass distance and slope comparison cuts. 
In this mode the fake rate for each track in minimised and this is very useful for alignment. However the number of tracks will suffer, so it is usesful to have a less stringent pattern recognition. 

The second is the doublet finder (track mode, mode 0): This will use two planes specified by the user to find doublets, so hits close in the global x/y frame. When it finders a hit on each plane which looks like it comes from a track it extrapolates a parameterised track from these and collects hits within a certain range. If enough hits are collected then the track is assumed correct and passed. 

The mode and cuts can be set in the config, both modes change what cut are used. For each mode the cuts of interest are:


For mode 1 the cuts are like so and performed in this order:
#DoubletDistCut = 1 1 <<<This is the distance between hits on the outer planes of each arm (So planes 0,2 and 3,5). If under this create a doublet from two hits 
#DoubletCenDistCut = 1 1  <<<This is distance between the prediction of the doublet on the central plane of each arm and the nearest hit. If under this form triplet.
#TripletConnectDistCut = 0.5 0.5 <<< The triplets formed on each arm are then extrapolated to a central point and compared. If distance is larger than this no track formed.
#TripletSlopeCuts = 0.5 0.5 <<< The triplets on each arm also compared at a central point for slope differences. If passed this then you have a final track.
>>>>>>>Last cut internal. If a triplet has more than one match to another triplet on the other arm remove this triplet from the search. IMPORTANT TO NOTE: So if you make the triplet cuts wide then you will get no tracks since you had lots of multiple matching.

For mode 0 the cuts are like so and performed in this order:
#doubSens = 0 5  <<< This is not a cut but the planes to search for doublets over.
#DoubletDistCut = 1 1 <<<Create doublets from planes specified in doubSens and under this cut. 
#DoubletCenDistCut = 1 1  <<< Extrapolate the doublet and collect all hits on the path under this abs(meas-pred) cut.
#hitNum = 5 << Every track must have at least this number of hits. If so then form a final track.

At this point it is good to note how this process is split between EUTelPatRecTriplet.cc and EUTelNav.cc. EUTelNav.cc contains all the information to create track parameterisations from hits. It also links state parameters (position, incidence, q/p) to other states on other planes, this is in the form of a jacobian 5x5 matrix. EUTelTriplet just uses this information in specific ways to link the correct hits together which form a track. There is one more class which is used EUTelTrackCreate, this will use EUTelNav to create parameterised track and then add the measured hits to this. 

##GBLFitting

A track in EUTelescope with GBL is called EUTelTrack. This contains all the information track wide(chi2,degrees of freedom,charge/momentum).
Inside EUTelTrack you can access a vector of EUTelState objects. Each EUTelState contains the predicted position and incidence on each plane. 
Inside each EUTelState is a single EUTelHit object. EUTelHit is the measured hit position on each plane.
In addition to this you also have what is known as a block in each EUTelState. This is simply a struct object which can easily be created by any class or processor. (See EUTelBlock.h). It contains information which is needed by each state to work out how to model radiation length. This is created in EUTelRadCal at the moment.

The GBL fitter can take an EUTelTrack object composed only of hits. 
It will then do the parameterisation of the track internally. This allows the minimum amount of work to be done to integrate a new pattern recognition. However it could be useful in the long run to be able to pass a track which has already been parameterised. An example would be a second iteration with GBL with kinks. This is also possible and to change between these two modes change:

#mode = 1 <<<1 mean the GBL fitter will do the work for you in creating a predicted track from the hits.  

All planes included in the fit will have a state produce on them (So position and incidence). Planes excluded are removed from the fit but the radiation length is still included. Radiation length is described by the block in EUTelState. So a single block is the radiation length of the included plane and the inhomogeneous mass infront of it until the next included plane. This mass would be air and excluded sensors but could include anything as long as it is in the gear. Note the block contains the information to describe the thick scatterers which is the inhomogenous mass after the sensor by only two scattering points. 

With:
1) A parameterised track. (Determined from hits)
2) Z position of all points to be placed, including the scattering points( Point GBL slang for state)
3)Measurements and their errors 
4) Scattering and their errors

You have all the information needed to create a GBL track this comes in 5 parts in the EUTelGBLFitter.

1)The initial trajectory is created using the parameterised track and the blocks to determine the z positions of the scatterers. This initial trajectory is nothing more than a series of positions/incidences at different z postions (on the planes) linked together. This linking is done via a jacobians which relates the change in position/incidence at one point to another. The blocks are needed NOT to add scattering (This is done in part 2). It is there since the position of the points to describe scattering depend on the material distribution. 

 GBL uses labels - starting at 1 then increasing - to identify points on the trajectory. These labels are stored on the EUTelState. 3 point labels for each state, 1 for the plane itself, 2 for the scatterering points to describe the mass in front of that sensor. 

2) The measurements + errors are then added to points which have a measurement. This is done using the label of the GBL points which are on a sensor and checking we have a hit to add.

3) The kinks + errors are added to all points. In nearly all cases the kinks initial value is 0. The errors are determined from the radiation lengths in the block and the Highland formula.IMPORTANT: The Highland formula is non linear with addition. So the variance of the system as a whole is determined and split between each part weighted to the radiation length of each part relative to the total.

4) USED FOR ALIGNMENT ONLY! This is where we add the global parameters which are the same for every track. This is used for alignment but could be anything. It is only a link between the residual and some parameter using a first order derivative.

5) USED FOR KINK ESTIMATION ONLY! This is where we add the local parameters which vary from track to track (In contrast to global which is the same for all tracks). Keep in mind that global/local ALWAYS link some parameter to the residuals at that point on the track. An example with local parameters is the estimation of kink angle using this distance from the plane of interest to the planes downstream. Here the distance links the residuals downstream from the scatterer to the kink angle on the scatter. 


